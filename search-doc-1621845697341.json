[{"title":"打包费","type":0,"sectionRef":"#","url":"了解UENC/打包费","content":"打包费是公网节点通过设置处理交易获得的uenc数量。","keywords":""},{"title":"UENC开发者","type":0,"sectionRef":"#","url":"开发者/UENC开发者","content":"","keywords":""},{"title":"硬件要求：","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#硬件要求：","content":"cpu： 4核 内存：4G 磁盘： 最少50G  "},{"title":"操作系统:","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#操作系统","content":"*Centos7版本(CentOS是免费的、开源的、可以重新分发的开源操作系统 ，CentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是Linux发行版之一) "},{"title":"开发环境：","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#开发环境：","content":"1. 升级自己的gcc编译器到8.3.1：# gcc是一套由GNU工程开发的支持多种编程语言的编译器。 GCC是自由软件发展过程中的著名例子，由自由软件基金会以GPL协议发布。 GCC是大多数类Unix操作系统（如Linux、BSD、Mac OS X等）的标准的编译器， GCC同样适用于微软的Windows。GCC支持多种计算机体系芯片，如x86、ARM，并已移植到其他多种硬件平台。  yum install centos-release-scl scl-utils-build yum install -y devtoolset-8-toolchain scl enable devtoolset-8 bash Copy 查看是否升级成功:  gcc --version Copy 2. 查看、关闭、开启系统防火墙# 所谓“防火墙”是指一种将内部网和公众访问网（如Internet）分开的方法， 它实际上是一种建立在现代通信网络技术和信息安全技术基础上的应用性安全技术，隔离技术。 越来越多地应用于专用网络与公用网络的互联环境之中，尤其以接入Internet网络为最甚。 sudo systemctl status firewalld systemctl stop firewalld.service systemctl start firewalld.service Copy 3. git安装：# Git（读音为/g?t/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 (1).删除旧版本的git# 执行: yum remove git。 Copy (2).在线安装# yum install git Copy "},{"title":"获取UENC源码","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#获取uenc源码","content":"git clone https://github.com/uenctech/uenc_src Copy "},{"title":"编译运行","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#编译运行","content":"安装依赖库：#  yum install -y zlib zlib-devel yum install -y unzip zip yum install -y autoconf automake libtool Copy 执行make开始编译，编译时提示说libprotobuf.a: 没有那个文件或目录，删除protobuf目录重新编译。 编译完成后生成可执行文件ebpc_xxxxx_testnet。 "},{"title":"运行时生成的文件和目录的介绍：","type":1,"pageTitle":"UENC开发者","url":"开发者/UENC开发者#运行时生成的文件和目录的介绍：","content":"运行程序 ./ebpc_xxxxx_testnet Copy 程序运行起来后按下Ctrl+C键退出。此时会生成 cert 目录及config.json,data.db,devpwd.json,log.txt文件。这些目录和文件介绍如下： 文件或目录\t描述cert\t存放生成的公私密钥对，后缀为\".public.key\"的文件是公钥文件，后缀为\".private.key\"为私钥文件 data.db\t数据库文件 devpwd.json\t本机访问密码哈希值，当移动端连接时使用该密码进行连接 config.json\t配置文件 log.txt\t日志文件 修改config.json 自己节点是子网节点无需配置，可按默认配置直接运行。如果是公网节点按照如下配置： 需要将is_public_node的值由false修改为true。 将server中的IP字段的值设置为自身节点所连接的其他公网节点IP地址。 将var字段下的local_ip字段设置为自身节点的外网IP地址。 例如，自身节点外网IP地址为xxx.xxx.xxx.xxx, 所连接公网地址为yyy.yyy.yyy.yyy, 则按如下配置（以测试网公网节点配置为例） \"is_public_node\": true, \"server\": [ { \"IP\": \"yyy.yyy.yyy.yyy\", \"PORT\": 11188 }, ], \"var\": { \"k_bucket\": \"a0dbbd80eb84b9e51f3a0d69727384c651f9bdb5\", \"k_refresh_time\": 100, \"local_ip\": \"xxx.xxx.xxx.xxx\", \"local_port\": 11188, \"work_thread_num\": 4 }, Copy ### 运行时参数介绍： 程序启动时是可以带参数的，参数说明如下: | 参数 |参数说明| |:---:|:---:| |--help |获取帮助菜单| |-m |显示菜单 | |-s |设置矿费 | |-p |设置打包费 | 列如设置矿费： Copy ./uenc_1.3_testnet -s 0.015 Copy  注意：实际值 = value * 0.000001。实际值最小值：0.000001。 #### 编译命令： make 生成测试网程序 make primary 生成主网程序 当编译出现问题需要重新编译时： 1.删除protobuf、crypto、rocksdb文件夹 2.make clean 3.make 或 make primary Copy "},{"title":"什么是质押","type":0,"sectionRef":"#","url":"了解UENC/什么是质押","content":"在uenc主网中，质押是节点通过锁定定量的uenc加入到uenc网络的行为。Uenc采用的是DPOW共识机制来选择验证节点，我们根据用户质押的uenc数量来作为节点的凭证。","keywords":""},{"title":"公网节点","type":0,"sectionRef":"#","url":"了解UENC/公网节点","content":"公网是连接子节点的中转节点，通过公网节点实现内外直连、外外直连、服务中转等","keywords":""},{"title":"DPOW共识算法","type":0,"sectionRef":"#","url":"了解UENC/DPOW共识算法","content":"Proof of Work，工作证明。DPOW即定向工作量证明（DIRECTIONAL PROOF OF WORK） UENC当中的DPOW算法是利用节点签名机制，发起节点对交易体进行签名经过网络传输到下一个节点，下一个节点会依次验证上次签名的节点，等签名个数达到设置的共识数的时候交易体返回给交易发起节点。","keywords":""},{"title":"UENC是什么","type":0,"sectionRef":"#","url":"了解UENC/UENC是什么","content":"Uenc是一个以跨链为技术方向的可扩展的基础公链，基于DHT网状网络、交叉式并行存储技术（CPS）等创新技术，通过自主研发DPOW共识算法，实现了高并发、高速度、低成本的用户链上交易体验，满足了未来通证经济高速发展的底层技术需求。 UENC是一个全球性的P2P(对等网络，即对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式.)网络 是记录全球所有在UENC链上的数据，它可以在UENC链上便捷地获取数据，同时具有出色的用户使用体验。","keywords":""},{"title":"其他钱包","type":0,"sectionRef":"#","url":"钱包/其他钱包","content":"Fastoken作为Uenc网络的专有钱包，不支持多链且功能相对单一。因此我们希望社区能够提供更多可支持Uenc网络，且功能丰富体验友好的第三方钱包来对接。钱包的对接见开发者模块。","keywords":""},{"title":"Fastoken钱包","type":0,"sectionRef":"#","url":"钱包/Fastoken钱包","content":"","keywords":""},{"title":"1.需要先下载app","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#1需要先下载app","content":"打开官网 最下边有带M的按钮，把鼠标放在它的右边的按钮上会弹出两个二维码，一个是Energy Club一个是Fastoken，扫二维码Fostoken安装app。 app安装成功后 "},{"title":"2.创建数字身份","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#2创建数字身份","content":"安装成功后打开app进入欢迎页面。 点击欢迎页面的Agree按钮进入创建数字身份页面，在此页面手机会询问\"Fastoken\"需要使用存储权限是否允许，点击下面的始终允许按钮。点击右上方的中英文切换按钮下面会 弹出三个按钮分别是简体中文，English，Cancel。 点击简体中文按钮开始创建数字身份 按要求输入身份名（最大长度14）和密码及重复密码点击创建按钮进入备份助记词页面。  "},{"title":"3.备份助记词","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#3备份助记词","content":"点击上一步的创建后进入提示你备份助记词的页面。 仔细阅读页面内容后点击下一步（或者稍后备份）弹出助记词页面让你备份。 备份助记词后点击下一步此时要你按刚才的助记词的顺序点击出现的助记词。 操作完后点击完成按钮回到首页。 "},{"title":"4.连接节点","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#4连接节点","content":"助记词备份成功后，回到首页当前显示是主账号（高亮显示）。 此时还未连接节点，点击节点切换到节点账号 点击节点下面的 + 进入节点搜索列表 在节点列表中选择一台节点进行连接（备注：手机端必须连接wi-fi，且手机端wi-fi与连接的节点在同一局域网内） 选择一台节点，点击连接节点，弹出输入密码框，节点默认密码是12345678，输入密码。 点击完成按钮如果连接成功会弹出如下页面 点击上面页面的立即设置会进入设置燃料费页面。 "},{"title":"5.设置燃料费","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#5设置燃料费","content":"节点连接成功后点击立即设置进入设置燃料费界面，可以设置修改当前节点燃料费。 阅读上面内容后输入燃料费点击保存，返回节点列表界面。  "},{"title":"6.主账号发起转账","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#6主账号发起转账","content":"回到首页切换到主账号 点击转账按钮，进入转账页面。 输入转账地址交易金额拖动签名费的小圆圈设置签名费，点击共识数的-或+设置共识数。点击选择交易节点右下方的箭头进入节点设置页面。 点击要选择的节点返回到转账界面，点击转账按钮进入确认转账界面点击确认转账系统提示交易发起成功。 "},{"title":"7.节点账号发起转账","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#7节点账号发起转账","content":"进入首页点击节点切换到节点账号。 在节点账号点击转账按钮，进入转账页面。 输入钱包地址交易金额。在单节点签名费下面拖动小圆圈设置签名费，点击共识数右面的-或+设置签名费。节点发起转账交易节点不用选择。 点击转账按钮弹出输入节点密码界面 输入密码后点击完成弹出确认转账页面 阅读界面上的信息后点击确认转账按钮系统提示提交成功。 "},{"title":"8.查看交易情况","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#8查看交易情况","content":"在首页点击进入钱包右面的小箭头进入钱包 钱包页面 在此页面中可以查看你的交易是失败还是成功或在交易中。 "},{"title":"9.主账号退出","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#9主账号退出","content":"如果有多个主账号，正在使用的主账号不可以退出。 按下高亮显示的主账号按钮左滑出现设置按钮 点击设置按钮进入设置页面 退出前如果没有备份助记词系统提示让你备份助记词，备份后点击退出当前账号按钮会弹出密码框，输入密码后点击确认后退出主 账号返回到注册数字身份页面。 "},{"title":"10.恢复账号","type":1,"pageTitle":"Fastoken钱包","url":"钱包/Fastoken钱包#10恢复账号","content":"两种方式：1助记词恢复；2私钥恢复。 在首页点击钱包管理按钮，进入钱包管理界面点击右下角的创建按钮。 进入创建数字身份页面，点击最下面的恢复身份按钮进入恢复身份页面。 选择助记词或私钥恢复身份。 "},{"title":"常见问题","type":0,"sectionRef":"#","url":"社区讨论/常见问题","content":"","keywords":""},{"title":"Liunx常见问题","type":1,"pageTitle":"常见问题","url":"社区讨论/常见问题#liunx常见问题","content":"怎么购买云服务器？ 以下以阿里云为例 1.注册阿里云账户 2.注册完成点击产品，选择“云服务器ECS\"3.进入页面点击，直接购买。进入服务器配置页面 可以按照如图配置页面购买，此配置是根据主网搭建硬件要求，页面内存可以选择4G， 内网带宽不做限制，外网带宽按自己需求选择 选择完成点击“确认订单”，完成支付就成功购买了一台服务器。 查看自己所购买的服务器，点击右上角的控制台，选择实例，在实例中可以看到自己购买的服务器 运行解压缩出来的文件提示版本错误？ 此问题是网络中存在低版本的主网程序，检查自己安装的版本是否是最新版本。如果是不予理睬。 "},{"title":"节点常见问题","type":1,"pageTitle":"常见问题","url":"社区讨论/常见问题#节点常见问题","content":"区块高度不同步 区块卡在某高度不动 节点密码忘记 "},{"title":"手机连接问题","type":1,"pageTitle":"常见问题","url":"社区讨论/常见问题#手机连接问题","content":"交易签名失败 交易签名失败通常有如下情况： 1.交易没有发出 2.网络节点当中质押节点过少，没有设置矿费。 3.同一个账号不能连着做交易 搜索不到节点 搜索不到节点通常是手机wifi与节点wifi不在同一网段内。 解质押失败 解质押的时候要求本笔资产要在30天之后才可以解质押这笔质押资产。 "},{"title":"其他问题","type":1,"pageTitle":"常见问题","url":"社区讨论/常见问题#其他问题","content":"交易不成功 可能原因 ： 1.判断节点是否连接到服务器 能否ping通公网服务器。11187、11188、11190端口是否开放。 2.看余额是否够即手续费+交易费是否小于余额 运行程序 ./uenc_xxx_testnet -m Copy 运行起来后会出现如下信息： Version: 1_xxx_t Base58: 15md8eripkG9n4hGMNacEar7AqTfudvWBZ Balance: 0 Mac md5: 887da3c400cd1fcaf2d5431abcbc647d Signature Fee: 1100 Package Fee: 0 Block top: 1919 Top block hash: d955017db4475742caeb9b9d143c7d9b79126b9c4e5cee1b55f735b00f42fdbd Copy Balance是你的余额。你的交易费+矿费X（共识数-1）是你的本次交易总费用。看余额是否大于总费用。 3.是否设置矿费 signature是矿费，看是否设置矿费，设置矿费：  ./uenc_xxx_testnet -s 0.015 Copy 4.本节点的块高度和全网节点的块高度是否一致 Block tops是块高度,并通过浏览器查看高度是否一致。 Q&A: 手机端连接节点失败：手机端wi-fi要与连接的节点的网络在同一局域网内。 手机端交易失败：手机端在交易时矿费设置过低容易失败，共识数设置的过多容易失败。 手机端质押：手机端最小质押数为500UENC，并且30天之后才可以解质押这笔质押资产。 不能发起交易：当前节点账号是否在挂起列表当中，当前节点的高度是否与主网高度在5个高度之内。 ## [发布问题](https://www.uenc.io/#/pro) "},{"title":"节点部署","type":0,"sectionRef":"#","url":"UENC节点/节点部署","content":"","keywords":""},{"title":"准备工作","type":1,"pageTitle":"节点部署","url":"UENC节点/节点部署#准备工作","content":"了解linux系统# 一、linux系统的连接# 二、 linux的基础命令# 这里只介绍本程序常用到的一些linux命令，其他linux命令详见： #ls -- 查看当前文件目录#chmod 755 文件名 -- 给文件赋予当前用户可读可执行权限#cd /目录 -- 到对应根目录下#vim config.json --进入文件进行编辑，按i键进行编辑修改，完成按Esc键 输入:wq!回车退出灵活运用Tab键，当控制台输入文件或目录，可以用tab键补齐文件目录。灵活运用up,down键，当要重新输入之前输过的命令，可以按up键查找，省去重新输入。 部署环境准备# 硬件要求：# UENC程序在运行的时候需要开辟一点的内存开销。 cpu ：4核 内存：4G 磁盘：至少50G 操作系统：# CentOS 7版本(CentOS是免费的、开源的、可以重新分发的开源操作系统 ，CentOS（Community Enterprise Operating System，中文意思是社区企业操作系统）是Linux发行版之一)通过购买云服务器或者实体服务器。 代码准备#  tips:进行接下来的操作之前要先熟悉，学习linux系统控制台的[基础命令](https://m.runoob.com/linux/linux-command-manual.html)。 可以从github(GitHub是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。)上直接下载 适用于CentOS 7 环境下的二进制程序。 也可以通过以下方法下载： 下载主网程序（uenc_xxx_primarynet.zip） git clone https://github.com/uenctech/uenc-demo.git 在uenc目录下找到uenc_xxx_primarynet.zip并解压安装。 Copy 下载测试网程序(uenc_xxx_testnet.zip) git clone https://github.com/uenctech/uenc-demo.git 在uenc目录下找到uenc_xxx_testnet.zip并解压安装 Copy 下载后修改下载的安装文件的执行权限并解压缩。 修改执行权限 chmod 755 uenc_1.3_testnet.zip Copy 如上图可见，压缩文件.zip从红色变成了绿色。这也是判断是否权限赋予成功的标志。 解压 unzip uenc_1.3_testnet.zip Copy "},{"title":"文件结构介绍","type":1,"pageTitle":"节点部署","url":"UENC节点/节点部署#文件结构介绍","content":"解压缩完成之后查看文件结构 ls Copy 或者xftp查看 文件或目录\t描述.md\t以此后缀结尾的文档是提供给用户阅读的，其中包括开发对接文档 .assets\t是存放uenc主网的逻辑结构图，用户可以根据兴趣阅读 uenc\t本机访问密码哈希值，当移动端连接时使用该密码进行连接 libs_linux\t是提供给开发者对接主网liunx系统用到的静态库文件 libs_win32\t是提供给开发者对接主网windows系统用到的静态库文件 "},{"title":"节点配置","type":1,"pageTitle":"节点部署","url":"UENC节点/节点部署#节点配置","content":"进入到uenc目录 #cd uenc_1.5_xxx 运行获取的安装文件 tips:运行之前查看文件是否赋予可读可执行权限``` ./uenc_1.3_testnet ``` 执行后按Ctrl + C退出当前程序，此时会在当前目录中生成如下文件和目录 文件或目录\t描述cert\t存放生成的公私密钥对，后缀为\".public.key\"的文件是公钥文件，后缀为\".private.key\"为私钥文件 data.db\t数据库文件 devpwd.json\t本机访问密码哈希值，当移动端连接时使用该密码进行连接 config.json\t配置文件 log.txt\t日志文件 配置文档修改# 修改配置文件config.json，自己是子网节点无需配置，可按默认配置直接运行。 vim config.json Copy 编辑完成，进行退出。重新执 行./uenc_1.xx_xxx 命令，执行生效。 如果自己是公网节点按照如下方式进行修改： 需要将is_public_node的值由false修改为true。 将server中的IP字段的值设置为自身节点所连接的其他公网节点IP地址。 将var字段下的local_ip字段设置为自身节点的外网IP地址。 例如，自身节点外网IP地址为xxx.xxx.xxx.xxx, 所连接公网地址为yyy.yyy.yyy.yyy, 则按如下配置（以测试网公网节点配置为例） \"is_public_node\": true, \"server\": [ { \"IP\": \"yyy.yyy.yyy.yyy\", \"PORT\": 11188 }, ], \"var\": { \"k_bucket\": \"a0dbbd80eb84b9e51f3a0d69727384c651f9bdb5\", \"k_refresh_time\": 100, \"local_ip\": \"xxx.xxx.xxx.xxx\", \"local_port\": 11188, \"work_thread_num\": 4 }, Copy "},{"title":"使用节点","type":0,"sectionRef":"#","url":"UENC节点/使用节点","content":"","keywords":""},{"title":"参数介绍：","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#参数介绍：","content":"安装文件运行时后面是可以带参数的，参数介绍如下。 --help\t获取帮助菜单-m\t显示菜单 -s\t设置矿费 -p\t设置打包费 "},{"title":"菜单介绍：","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#菜单介绍：","content":"测试节点命令：  ./uenc_xxx_testnet -m Copy 公网节点命令：  ./uenc_xxx_primarynet -m Copy 程序启动之后，可以看到如下菜单：  1.Transaction 2.Pledge 3.Redeem pledge 0.exit Please input your choice: Copy 如下图所示： "},{"title":"生成账户","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#生成账户","content":"在执行./uenc_xxx_testnet 出现如上信息。其中的RegisterCallback bs58Addr :xxxxxxxx是本节点生成的钱包地址。请妥善保管此钱包地址，挖矿所得的收益都在这个钱包地址里面。 "},{"title":"设置打包费","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#设置打包费","content":"列如设置矿费： 测试节点：  ./uenc_1.3_testnet -s 0.015 Copy 正式节点：  ./uenc_1.3_primarynet -s 0.015 Copy 注意：实际值 = value * 0.000001。实际值最小值：0.000001。 "},{"title":"设置签名费","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#设置签名费","content":"程序启动之后按数字9进入如下菜单 1.ca 2.net 3.gen key 4.transation 5.test get amount 7.gen usr 8.out private key 9.in private key x.test gen tx 0.quit Please input your choice: Copy ，然后按8.out private key就可以打印默认账号的私钥和助记词。 然后按1.ca进入ca菜单，然后再按9到如下菜单 1. Generate mnemonic words. 2. 模拟质押资产. 3. 得到本机设置的燃料费和全网节点最大最小平均值燃料费 4. 根据UTXO查询余额 5. 设置节点签名费 8. 模拟解质押资产 9. 查询账号质押资产额度 10.多账号交易 11.查询交易列表 12.查询交易详情 13.查询区块列表 14.查询区块详情 15.查询所有质押地址 16.获取5分钟内总块数 17.设置节点打包费用 18.获得所有公网节点打包费用 19.自动乱序交易(简化版) 20.测试获取前100块各个账号奖励 21.通过交易hash获取块信息 22.获取失败交易列表信息 23.获取节点高度是否符合高度范围。 Copy 然后在按5进入节点签名费设置 "},{"title":"导出&&保存私钥","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#导出保存私钥","content":"程序启动之后按数字8导出私钥，9进入如下菜单 程序启动之后按数字9进入如下菜单，然后按8.out private key就可以打印默认账号的私钥和助记词。 1.ca 2.net 3.gen key 4.transation 5.test get amount 7.gen usr 8.out private key 9.in private key x.test gen tx 0.quit Copy 如下图所示： "},{"title":"进行转账","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#进行转账","content":"1.Transaction 表示发起交易，注意发起交易前需要设置矿费且矿费值在0.001与0.1之间. 输入1回车会让你输入自己的账号地址：  input FromAddr : 12GwpCQi7bWr8cbmU2r1aFia1rUQJDVXdo Copy 输入自己账号地址后回车此时会让你输入对方账号地址  input ToAddr： 1vkS46QffeM4sDMBBjuJBiVkMQKY7Z8Tu Copy 输入对方账号地址后回车系统会提示让你输入交易金额  input amount : 999999 Copy 输入交易金额后回车系统会提示让你输入需要签名的数量，签名数量最小值6最大值15。  input needVerifyPreHashCount : 6 Copy 输入签名数后回车系统提示你输入手续费注意手续费范围也是在0.001与0.1之间。  input minerFees : 0.012 Copy 输入后回车交易发起完毕。 "},{"title":"质押","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#质押","content":"测试网络质押之前，需向水龙头账号申请定量金额，进行质押、解质押操作 2.Pledge 表示质押。 出现初始菜单后输入2回车注意此时质押的账号是你自己的本机账号，系统此时提示输入质押金额：  请输入要质押金额： 325555 Copy 输入金额后回车系统提示你输入矿费  请输入GasFee: 0.014 Copy 输入后回车系统提示你输入密码  password: 158660 Copy 输入密码后回车质押完毕。 "},{"title":"解质押","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#解质押","content":"3.Redeem pledge表示解质押。 输入3回车会提示你输入解质押的账号  Selected redeem pledge. addr： 12GwpCQi7bWr8cbmU2r1aFia1rUQJDVXdo Copy 输入后回车系统列出当前账号的所有utxo  -- 目前已有质押 -- utxo: e77074aa69a97ea6f018bc4ef5d4fa643e823c46ab6c59958c0e5d288befbe8d Copy 输入你要解质押的utxo(复制后粘贴)回车解质押完毕。 "},{"title":"挖矿","type":1,"pageTitle":"使用节点","url":"UENC节点/使用节点#挖矿","content":"节点要想在后台实现挖矿首先自身必须要进行质押，如果不质押在发起交易的时候签名节点会被剔除，自身还有设置节点签名费，然后启动守护进程 ./ebpc_daemon ./ebpc_xxx_testnet ./ebpc_xxx_testnet Copy 启动守护进程之后就不能进行config的配置也不能再次启动程序，除非杀死守护进程，在重新启动程序。 "},{"title":"开放接口","type":0,"sectionRef":"#","url":"开发者/开放接口","content":"","keywords":""},{"title":"Protobuf接口","type":1,"pageTitle":"开放接口","url":"开发者/开放接口#protobuf接口","content":"请求数据规范# 所有网络请求需按照协议规范（数据格式）将数据组织好后，使用socket连接方式发送到主网节点（端口为11187），当主网节点收到请求后将按照同样协议规范（数据格式）返回给请求方，请求方需自行解析相关数据获得接口返回信息。 请求协议中部分信息是以protobuf方式进行封装，封装后序列化后填充请求协议中进行发送。一般请求协议的名称以Req结尾，发送到主网后，主网后会返回Ack结尾的protobuf数据体进行回应。例如请求获得余额的子协议接口为GetAmountReq，则主网服务器收到该请求后的回应数据体为GetAmountAck。 请求协议的数据格式如下： 协议总长度\t通用协议\t校验和\t标志位\t结束标志4bytes\t序列化后的字符串\t4bytes\t4bytes\t4bytes 协议总长度 该字段4字节，记录接下来的 通用协议 + 校验和 + 标志位 + 结束标记的总长度。假设通用协议100个字节，校验和4个字节，标志位4个字节，结束标记4个字节，则总长度为100 + 4 + 4 + 4 = 112字节。 通用协议 通用协议为profobuf格式，原型如下： message CommonMsg { string version = 1; string type = 2; int32 encrypt = 3; int32 compress = 4; bytes data = 5; } Copy 字段\t说明version\t版本号 type\t子协议类型名称，根据实际业务需要填充接口名称，如”GetAmountReq” encrypt\t是否加密，1为加密，0为不加密，默认为0 compress\t是否压缩，1为压缩，0为不压缩，默认为0 data\t子协议接口protobuf数据体序列化后的数据,请求时需要将子协议接口的protobuf类型数据序列化后，填充到data中后进行发送。 标志位 标志位长度为4字节，结构如下： 3\t2\t1\t0保留\t保留\t保留\t优先级 优先级：默认为0。 校验和 - 校验和长度为4字节，是通用协议序列化后，通过Adler32算法计算出来的校验和信息。 Copy 结束标志 - 结束标记长度为4字节，其内容为7777777。 4. 将请求协议发送到主网后，主网也按照请求协议格式封装回传信息传送给请求方，请求方收到信息后： Copy 根据协议总长度获得完整回传信息。根据协议总长度获得通用协议、校验和、标志位以及结束标志。根据校验和判断通用协议是否完整。通过反序列化通用协议，获取子协议（接口）名称和子协议（接口）的数据内容。根据通用协议中的压缩和加密字段，确定是否对子协议（接口）的数据内容进行解压缩或解密操作。将子协议的数据内容按照子协议的protobuf格式进行反序列化，获得完整的子协议（接口）请求内容。 接口介绍# 一、设置设备密码接口（SetDevPasswordReq）# 请求 message SetDevPasswordReq { string version = 1; string old_pass = 2; string new_pass = 3; } Copy 字段\t说明version\t版本号 old_pass\t旧密码 new_pass\t新密码 响应 message SetDevPasswordAck { string version = 1; sint32 code = 2; string description = 3; } Copy 字段\t说明version\t版本号 code\t0成功; -1参数错误; -2 密码不能为空; -3旧密码非法（特殊字符或长度超过8个字节）; -4 新密码非法（特殊字符或长度超过8个字节）; -5 新旧密码不能相同; -6 旧密码验证不正确; -7 未知错误 description\t返回值的文字描述 代码示例 # 设置设备密码接口（SetDevPasswordReq） def SetDevPasswordRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' OLD_PASS = 11111111 NEW_PASS = 12345678 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.SetDevPasswordReq() addr.version = VERSION addr.old_pass = str(OLD_PASS) addr.new_pass = str(NEW_PASS) common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'SetDevPasswordReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.SetDevPasswordAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_SetDevPasswordAck = protobuf_to_dict(target) json_output = json.dumps(message_SetDevPasswordAck, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 二、设置矿工费请求接口（SetServiceFeeReq）# 请求 message SetServiceFeeReq { string version = 1; string password = 2; string service_fee = 3; } Copy 字段\t说明version\t版本号 password\t节点密码 service_fee\t设定值 响应 message SetServiceFeeAck { string version = 1; sint32 code = 2; string description = 3; } Copy 字段\t说明version\t版本号 code\t0成功; -6 密码错误; -7 滑动条数值显示错误 description\t返回值的文字描述 代码示例 # 设置矿工费请求接口（SetServiceFeeReq） def SetServiceFeeRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' PASSWORD = 12345678 SERVICE_FEE = 0.01 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.SetServiceFeeReq() addr.version = VERSION addr.password = str(PASSWORD) addr.service_fee = str(SERVICE_FEE) data_len_ = len(addr.service_fee) sum_ = (58 + data_len_) - 8 data_len_ = ('<i%dsIi' % sum_) common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'SetServiceFeeReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.SetServiceFeeAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_SetServiceFeeAck = protobuf_to_dict(target) json_output = json.dumps(message_SetServiceFeeAck, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 四、获取账户余额接口（GetAmountReq）# 请求 message GetAmountReq { string version = 1; string address = 2; } Copy 字段\t说明version\t版本号 address\t钱包地址 响应 message GetAmountAck { string version = 1; sint32 code = 2; string description = 3; string address = 4; string balance = 5; } Copy 字段\t说明version\t版本号 code\t返回0为成功, -1为钱包地址不可用 description\t返回值的文字描述 address\t钱包地址 balance\t余额 代码示例 # 获取账户余额接口（GetAmountReq） def GetAmountRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' ADDRESS = '13C4UmhB7tKGdXiJrp2GKsJtmCoJeqGJQz' # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetAmountReq() addr.version = VERSION addr.address = ADDRESS common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetAmountReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 结束标志位 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetAmountAck() while True: reply = pd.recv(4) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetAmountAck = protobuf_to_dict(target) json_output = json.dumps(message_GetAmountAck, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 五、获取特定节点打包费接口（GetPacketFeeReq）已废弃deprecated# 请求 message GetPacketFeeReq { string version = 1; string password = 2; string public_net_ip = 3; } Copy 字段\t说明version\t版本号 password\t节点密码 public_net_ip\t当前连接的的公网的ip 响应 message GetPacketFeeAck { string version = 1; sint32 code = 2; string description = 3; string packet_fee = 4; } Copy 字段\t说明version\t版本号 code\t0成功 description\t返回值的文字描述 packet_fee\t打包费 代码示例 # 获取特定节点打包费接口（GetPacketFeeReq） def GetPacketFeeRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' PASSWORD = 12345678 PUBLIC_NET_IP = '47.108.52.94' # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetPacketFeeReq() addr.version = VERSION addr.password = str(PASSWORD) addr.public_net_ip = PUBLIC_NET_IP common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetPacketFeeReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetPacketFeeAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetPacketFeeReq = protobuf_to_dict(target) json_output = json.dumps(message_GetPacketFeeReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 六、获得全网节点矿费接口（GetNodeServiceFeeReq）# 请求 message GetNodeServiceFeeReq { string version = 1; } Copy 字段\t说明version\t版本，目前暂时可为空 响应 message GetNodeServiceFeeAck { string version = 1; sint32 code = 2; string description = 3; repeated ServiceFee service_fee_info = 4; } message ServiceFee { string max_fee = 1; string min_fee = 2; string service_fee = 3; string avg_fee = 4; } Copy 字段\t说明version\t版本，目前暂时可为空 code\t0成功 description\t返回值的文字描述 service_fee_info\t节点矿费信息结构体数组 max_fee\t前一百块交易最大值 min_fee\t前一百块交易最小值 service_fee\t矿工设置的矿费 avg_fee\t前一百块交易平均值 七、根据密码获取钱包地址接口（GetDevPasswordReq）# 请求 message GetDevPasswordReq { string version = 1; string password = 2; } Copy 字段\t说明version\t版本号 password\t密码 响应 message GetDevPasswordAck { string version = 1; sint32 code = 2; string description = 3; string address = 4; } Copy 字段\t说明version\t版本号 code\t0成功; -2 密码错误 description\t返回值的文字描述 address\t钱包地址 3.代码示例 # 根据密码获取钱包地址接口（GetDevPasswordReq） def GetDevPasswordRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' PASSWODR = 12345678 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetDevPasswordReq() addr.version = VERSION addr.password = str(PASSWODR) common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetDevPasswordReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetDevPasswordAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetDevPasswordReq = protobuf_to_dict(target) json_output = json.dumps(message_GetDevPasswordReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 八、从服务器端获得客户端相关信息接口（GetClientInfoReq）# 请求 message GetClientInfoReq { string version = 1; DeviceType phone_type = 2; DeviceLang phone_lang = 3; string phone_version = 4; } Copy 字段\t说明version\t版本，目前暂时可为空 phone_type\t客户端类型 phone_lang\t所选语言 phone_version\t客户端所用版本 响应 message GetClientInfoAck { string version = 1; sint32 code = 2; string description = 3; string min_version = 4; string is_update = 5; string ver = 6; string desc = 7; string dl = 8 ; } enum DeviceType { PC = 0; iOS = 1; Android = 2; } enum DeviceLang { ZH_CN = 0; EN_US = 1; } Copy 字段\t说明version\t版本，目前暂时可为空 code\t-1,参数错误; -2,获得客户端信息错误，此情况是需要更新但是获得客户端下载信息是失败; 0 操作成功，但不需要更新，isUpdate为0，无客户端下载信息; 1 操作成功，包含所有字段信息 description\t返回值的文字描述 min_version\t服务器程序所支持的最小客户端版本 is_update\t是否升级, 1为需要升级, 0为不需要升级 ver\t所需下载客户端的版本 desc\t所需下载客户端的描述信息 dl\t所需下载客户端的Url PC\tpc端 iOS\tios端 Android\tandroid端 ZH_CN\t中文 EN_US\t英文 九、获取公网节点信息接口（GetNodeInfoReq）# 请求 message GetNodeInfoReq { string version = 1; } Copy 字段\t说明version\t版本 响应 message GetNodeInfoAck { string version = 1; sint32 code = 2; string description = 3; repeated NodeList node_list = 4; } message NodeList { repeated NodeInfos node_info = 1; string local = 2; } message NodeInfos { string enable = 1; string ip = 2; string name = 3; string port = 4; string price = 5; } Copy 字段\t说明version\t版本，目前暂时可为空 code\t0成功；-1获取失败 description\t返回值的文字描述 node_list\t节点信息结构体数组 node_info\t节点信息结构体 local\t地区 enable\t节点是否可用 ip\t节点ip name\t节点名称 port\t节点端口 price\t废弃 十、获取平均手续费、同步状态等信息接口（GetServiceInfoReq）# 请求 message GetServiceInfoReq { string version = 1; string password = 2; string public_net_ip = 3; bool is_show = 4; uint32 sequence_number = 5; } Copy 字段\t说明version\t版本号 password\t手机端密码(暂时不需要传) public_net_ip\t公网节点IP is_show\t非直连(通过节点)公网节点 需要传true(club可忽视此参数) sequence_number\t请求的序列号 (请求的时候传入什么值就会返回什么值) 响应 message GetServiceInfoAck { string version = 1; sint32 code = 2; string description = 3; string mac_hash = 4; string device_version = 5; repeated ServiceFee service_fee_info = 6; enum SyncStatus { TRUE = 0; FALSE = 1; FAIL = -1; } SyncStatus is_sync = 7; sint32 height = 8; //节点高度 uint32 sequence = 9; //回应的序列号 } message ServiceFee { string max_fee = 1; string min_fee = 2; string service_fee = 3; string avg_fee = 4; } Copy 字段\t说明version\t版本号 code\t0为成功; -1 版本错误返回值的文字描述; -404 连接公网超时 description\t返回描述 mac_hash\t废弃 device_version\t节点程序版本 service_fee_info\tServiceFee 手续费结构体 is_sync\tSyncStatus 是否同步枚举值 SyncStatus\t0 与主网同步; 1 与主网未同步; -1 获得主网信息失败 max_fee\t前一百块交易最大值 min_fee\t前一百块交易最小值 service_fee\t矿工设置的矿费 avg_fee\t前一百块交易平均值 SyncStatus\t0 节点与主网已同步; 1 节点与主网未同步; -1 获取主网信息失败 height\t节点高度或者公网高度(请求的是节点就是节点高度，请求的是公网就是公网高度) sequence\t请求端传入的序列号(请求端传入什么数据返回什么数据) 代码示例 # 获取平均手续费、同步状态等信息接口（GetServiceInfoReq） def GetServiceInfoRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' PASSWORD = 12345678 IS_SHOW = True SEQUENCE_NUMBER = 1 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetServiceInfoReq() addr.version = VERSION addr.password = str(PASSWORD) addr.public_net_ip = HOST addr.is_show = IS_SHOW addr.sequence_number = SEQUENCE_NUMBER common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetServiceInfoReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetServiceInfoAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetServiceInfoReq = protobuf_to_dict(target) json_output = json.dumps(message_GetServiceInfoReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十一、发起交易接口# 1.主网地址发起交易接口（CreateTxMsgReq）# 交易分两步 第一步: 请求 message CreateTxMsgReq { string version = 1; string from = 2; string to = 3; string amt = 4; string minerFees = 5; string needVerifyPreHashCount = 6; } Copy 字段\t说明version\t版本 from\t发起方钱包地址 to\t接收方钱包地址 amt\t交易金额 minerFees\t发起交易方支付的单个签名的矿工费 needVerifyPreHashCount\t签名共识数 version\t版本号 响应 message CreateTxMsgAck { string version = 1; int32 code = 2; string message = 3; string txData = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本 code\t0 为成功; -1 版本错误; -2 参数错误 ; -3 utxo未找到 message\t返回描述 txData\t交易信息体 txEncodeHash\t交易信息体base64之后sha256的hash值 第二步： 请求 message TxMsgReq { string version = 1; string serTx = 2; string strSignature = 3; string strPub = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本 serTx\t为第一次响应的txData strSignature\tbase64编码后的签名信息 strPub\t发起方公钥，需要base64编码。如果调用C动态库生成的公钥，需要将十六进制的字符串还原成二进制，再base64编码 txEncodeHash\t为第一次响应的txEncodeHash 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本 code\t0为发起交易成功，交易开始广播;; -1 版本错误; -2 反序列交易失败; -3 交易体无效; -4 数据库创建事务失败; -5 (未使用); -7 已经签名; -8 验证签名失败; -9 获取本节点签名费失败; -10 发起交易方支付的 GasFee 为 0; -11 未找到匹配的签名节点; message\t返回描述 txHash\t交易hash 2.手机端多重交易接口（CreateMultiTxMsgReq）# 交易分两步 第一步: 请求 message CreateMultiTxMsgReq { string version = 1; repeated string from = 2; repeated ToAddr to = 3; string minerFees = 5; string needVerifyPreHashCount = 6; } message ToAddr { string toAddr = 1; string amt = 2; } Copy 字段\t说明version\t版本 from\t发起方钱包地址 to\t接收方钱包地址数组 minerFees\t发起交易方支付的单个签名的矿工费 needVerifyPreHashCount\t共识数 toAddr\t接收方钱包地址 amt\t金额 响应 message CreateMultiTxMsgAck { string version = 1; int32 code = 2; string message = 3; string txData = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本 code\t0 为成功; -1 版本错误; -2 参数错误 ; -3 utxo未找到 message\t返回描述 txData\t交易信息体 txEncodeHash\t交易信息体base64之后sha256的hash值 第二步： 请求 message MultiTxMsgReq { string version = 1; string serTx = 2; repeated SignInfo signInfo = 3; string txEncodeHash = 4; } message SignInfo { string signStr = 1; string pubStr = 2; } Copy 字段\t说明version\t版本 serTx\t为第一次响应的txData signInfo\t签名信息数组 txEncodeHash\t为第一次响应的txEncodeHash signStr\tbase64之后签名信息 ？ pubStr\tbase64之后公钥 ？ 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本 code\t0为发起交易成功，交易开始广播; -1 版本错误; -2 反序列交易失败; -3 交易体无效; -4 数据库创建事务失败; -5 (未使用); -7 已经签名; -8 验证签名失败; -9 获取本节点签名费失败; -10 发起交易方支付的 GasFee 为 0; -11 未找到匹配的签名节点 message\t返回描述 txHash\t交易hash 3.手机端连接节点，控制节点发起交易发起交易接口（CreateDeviceTxMsgReq）# 交易分两步 第一步验证密码: 请求 message VerifyDevicePasswordReq { string version = 1; string password = 2; } Copy 字段\t说明version\t版本 password\t密码 响应 message VerifyDevicePasswordAck { string version = 1; int32 code = 2; string message = 3; } Copy 字段\t说明version\t版本 code\t返回错误码 message\t返回描述 第二步发起交易： 请求 message CreateDeviceTxMsgReq { string version = 1; string from = 2; string to = 3; string amt = 4; string minerFees = 5; string needVerifyPreHashCount = 6; string password = 7; } Copy 字段\t说明version\t版本 from\t交易发起方地址 to\t交易接收方地址 amt\t交易金额 minerFees\t发起交易方支付的单个签名的矿工费 needVerifyPreHashCount\t共识数 password\t节点密码 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本 code\t0为发起交易成功，交易开始广播; -1 版本错误; -2 反序列交易失败; -3 交易体无效; -4 数据库创建事务失败; -5 (未使用); -7 已经签名; -8 验证签名失败; -9 获取本节点签名费失败; -10 发起交易方支付的 GasFee 为 0; -11 未找到匹配的签名节点; message\t返回描述 txHash\t为空，无数据 4.手机端连接节点发起多重交易接口（CreateDeviceMultiTxMsgReq）# 请求 message CreateDeviceMultiTxMsgReq { string version = 1; repeated string from = 2; repeated ToAddr to = 3; string gasFees = 4; string needVerifyPreHashCount = 5; string password = 6; } Copy 字段\t说明version\t版本 from\t交易发起方地址 to\t交易接收方地址 gasFees\t发起交易方支付的单个签名的矿工费 needVerifyPreHashCount\t共识数 password\t节点密码 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本 code\t0为发起交易成功，交易开始广播; -1 版本错误; -2 反序列交易失败; -3 交易体无效; -4 数据库创建事务失败; -5 (未使用); -7 已经签名; -8 验证签名失败; -9 获取本节点签名费失败; -10 发起交易方支付的 GasFee 为 0; -11 未找到匹配的签名节点; message\t返回描述 txHash\t交易hash 十二、查询块信息接口（GetBlockInfoReq）# 请求 message GetBlockInfoReq { string version = 1; sint32 height = 2; sint32 count = 3; } Copy 字段\t说明version\t版本号 height\t高度 count\t一共需要查询的块数 响应 message GetBlockInfoAck { string version = 1; sint32 code = 2; string description = 3; //data uint64 top = 4; repeated BlockInfo block_info_list = 5; uint64 tx_count = 6; } message BlockInfo { sint32 height = 1; string hash_merkle_root = 2; string hash_prev_block = 3; string block_hash = 4; uint64 ntime = 5; repeated TxInfo tx_info_list = 6; string packet_fee = 7; string packet_ip = 8; } message TxInfo { string tx_hash = 1; repeated string transaction_signer = 2; repeated TxVinInfo vin_list = 3; repeated TxVoutInfo vout_list = 4; uint64 nlock_time = 5; string stx_owner = 6; uint64 stx_owner_index = 7; uint32 version = 8; } message TxVinInfo { string script_sig = 1; string pre_vout_hash = 2; uint64 pre_vout_index = 3; } message TxVoutInfo { string script_pubkey = 1; string amount = 2; } Copy 字段\t说明version\t版本号 code\t返回值 description\t返回描述 top\t块高度 block_info_list\tBlockInfo块信息结构体数组 tx_count\t交易数 height\t块高度 hash_merkle_root\tmerkle值 hash_prev_block\t上一个块hash block_hash\t块hash ntime\t建块时间 tx_info_list\tTxInfo 交易信息结构体数组 packet_fee\t打包费 packet_ip\t打包费节点ip tx_hash\t交易hash transaction_signer\t交易签名 vin_list\tTxVinInfo 交易vin信息结构体数组 vout_list\tTxVoutInfo 交易vout信息结构体数组 nlock_time\t建块时间 stx_owner\t交易方钱包地址 stx_owner_index\t交易方钱包地址索引号 version\t交易版本号 script_sig\t签名 pre_vout_hash\tvout hash pre_vout_index\tvout hash索引 script_pubkey\t钱包地址 amount\t金额 3.代码示例 # 查询块信息接口（GetBlockInfoReq） def GetBlockInfoRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' HEIGHT = 1 COUNT = 5 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetBlockInfoReq() addr.version = VERSION addr.height = HEIGHT addr.count = COUNT common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetBlockInfoReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetBlockInfoAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetBlockInfoReq = protobuf_to_dict(target) json_output = json.dumps(message_GetBlockInfoReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十三、根据钱包地址查询交易信息接口（GetAddrInfoReq）# 请求 message GetAddrInfoReq { string version = 1; string address = 2; uint32 index = 3; uint32 count = 4; } Copy 字段\t说明version\t版本号 address\t钱包地址 index\t查询第一个块的索引(第一次传-1) count\t一共需要查询的块数 响应 message GetAddrInfoAck { string version = 1; sint32 code = 2; string description = 3; uint64 total = 4; repeated BlockInfo block_info_list = 5; } message BlockInfo { sint32 height = 1; string hash_merkle_root = 2; string hash_prev_block = 3; string block_hash = 4; uint64 ntime = 5; repeated TxInfo tx_info_list = 6; string packet_fee = 7; string packet_ip = 8; } message TxInfo { string tx_hash = 1; repeated string transaction_signer = 2; repeated TxVinInfo vin_list = 3; repeated TxVoutInfo vout_list = 4; uint64 nlock_time = 5; string stx_owner = 6; uint64 stx_owner_index = 7; uint32 version = 8; } message TxVinInfo { string script_sig = 1; string pre_vout_hash = 2; uint64 pre_vout_index = 3; } message TxVoutInfo { string script_pubkey = 1; string amount = 2; } Copy 字段\t说明version\t版本号 code\t0 为成功; -1 获取失败 没有交易块产生; -2 起始索引超出范围 description\t返回描述 total\t返回总数 block_info_list\tBlockInfo块信息结构体数组 height\t块高度 hash_merkle_root\tmerkle值 hash_prev_block\t上一个块hash block_hash\t块hash ntime\t建块时间 tx_info_list\tTxInfo 交易信息结构体数组 packet_fee\t打包费 packet_ip\t打包费节点ip tx_hash\t交易hash transaction_signer\t交易签名 vin_list\tTxVinInfo 交易vin信息结构体数组 vout_list\tTxVoutInfo 交易vout信息结构体数组 nlock_time\t建块时间 stx_owner\t交易方钱包地址 stx_owner_index\t交易方钱包地址索引号 version\t交易版本号 script_sig\t签名 pre_vout_hash\tvout hash pre_vout_index\tvout hash索引 script_pubkey\t钱包地址 amount\t金额 3.代码示例 # 根据钱包地址查询交易信息接口（GetAddrInfoReq） def GetAddrInfoRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' ADDRESS = '13C4UmhB7tKGdXiJrp2GKsJtmCoJeqGJQz' INDEX = 1 COUNT = 5 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetAddrInfoReq() addr.version = VERSION addr.address = ADDRESS addr.index = INDEX addr.count = COUNT common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetAddrInfoReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) # print('Splicing_String\"', Splicing_String) pd.send(Splicing_String) target = protobuf_pb2.GetAddrInfoAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetAddrInfoReq = protobuf_to_dict(target) json_output = json.dumps(message_GetAddrInfoReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十四、获取节点公私钥助记词请求（GetDevPrivateKeyReq）# 请求 message GetDevPrivateKeyReq { string version = 1; string password = 2; string bs58addr = 3; } Copy 字段\t说明version\t版本号 password\t节点密码 bs58addr\tBase58地址 响应 message GetDevPrivateKeyAck { string version = 1; int32 code = 2; string description = 3; repeated DevPrivateKeyInfo devprivatekeyinfo = 4; } message DevPrivateKeyInfo { string base58addr = 1; string keystore = 2; string mnemonic = 3; } Copy 字段\t说明version\t版本号 code\t返回错误码 description\t返回错误信息 devprivatekeyinfo\t设备私钥信息 base58addr\tBase58地址 keystore\tkeystore mnemonic\t助记词 十五、（解）质押接口# 1.发起质押请求(主网请求)（CreatePledgeTxMsgReq）# 第一步： 请求 message CreatePledgeTxMsgReq { string version = 1; string addr = 2; string amt = 3; string needVerifyPreHashCount = 4; string gasFees = 5; } Copy 字段\t说明version\t版本号 addr\t质押地址 amt\t质押金额 needVerifyPreHashCount\t签名个数 gasFees\t燃料费 响应 message CreatePledgeTxMsgAck { string version = 1; int32 code = 2; string message = 3; string txData = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本号 code\t0 成功； -1 版本错误； -2 参数错误； -3 创建事务失败； -4 创建交易体失败 description\t返回错误信息 txData\t交易信息体 txEncodeHash\t交易信息体base64之后sha256的hash值 第二步： 请求 message PledgeTxMsgReq { string version = 1; string serTx = 2; string strSignature = 3; string strPub = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本号 serTx\t交易信息体 strSignature\t签名信息 strPub\t发起方公钥 txEncodeHash\t交易信息体base64之后sha256的hash值 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本号 code\t0 成功； -1 交易体类型错误； -2反序列化接收数据失败； -3 交易体不合法； -4 事务创建失败； -7 已经签名，无需重复签名； -8 验证签名失败； -9 节点未设置签名费； -10 发起方支付的燃油费为0； -11 找不到可签名的节点； -101 版本不兼容； -102 事务创建失败 message\t返回错误信息 txHash\t交易hash 2. 解除质押(主网请求)（CreateRedeemTxMsgReq）# 第一步： 请求 message CreateRedeemTxMsgReq { string version = 1; string addr = 2; string amt = 3; string needVerifyPreHashCount = 4; string gasFees = 5; string txHash = 6; } Copy 字段\t说明version\t版本号 addr\t解质押的地址 amt\t解质押金额 needVerifyPreHashCount\t共识数个数 gasFees\t燃料费 txHash\t交易hash 响应 message CreateRedeemTxMsgAck { string version = 1; int32 code = 2; string description = 3; string txData = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本号 code\t0 成功； -1 版本错误； -2 参数错误； -3 事务创建失败； -4 获取质押地址失败； -5 账号未质押； -6 获取块失败； -7 未找到块头； -8 获取质押的UTXO失败； -9 未找到质押的UTXO； -10 创建解质押交易失败； description\t返回错误信息 txData\t交易信息体 txEncodeHash\t交易信息体base64之后sha256的hash值 第二步： 请求 message RedeemTxMsgReq { string version = 1; string serTx = 2; string strSignature = 3; string strPub = 4; string txEncodeHash = 5; } Copy 字段\t说明version\t版本号 serTx\t交易信息体 strSignature\t签名信息 strPub\t发起方公钥 txEncodeHash\t交易信息体base64之后sha256的hash值 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本号 code\t0 成功； -1 交易体类型错误； -2反序列化接收数据失败； -3 交易体不合法； -4 事务创建失败； -7 已经签名，无需重复签名； -8 验证签名失败； -9 节点未设置签名费； -10 发起方支付的燃油费为0； -11 找不到可签名的节点； -101 版本不兼容； message\t返回错误信息 txHash\t交易hash 3.手机端连接节点发起质押交易请求（CreateDevicePledgeTxMsgReq）# 请求 message CreateDevicePledgeTxMsgReq { string version = 1; string addr = 2; string amt = 3; string needVerifyPreHashCount = 4; string gasFees = 5; string password = 6; } Copy 字段\t说明version\t版本号 addr\t质押的地址 amt\t质押金额 needVerifyPreHashCount\t共识数个数 gasFees\t燃料费 password\t密码 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本号 code\t返回错误码 message\t返回错误信息 txHash\t交易hash 4. 手机端连接节点发起解质押交易请求（CreateDeviceRedeemTxReq）# 请求 message CreateDeviceRedeemTxReq { string version = 1; string addr = 2; string needVerifyPreHashCount = 3; string gasFees = 4; string utxo = 5; } Copy 字段\t说明version\t版本号 addr\t质押的地址 needVerifyPreHashCount\t签名个数 gasFees\t燃料费 utxo\t要解压的utxo 响应 message TxMsgAck { string version = 1; int32 code = 2; string message = 3; string txHash = 4; } Copy 字段\t说明version\t版本号 code\t返回错误码 message\t返回错误信息 txHash\t交易hash 5.质押列表请求（GetPledgeListReq）# 请求 message GetPledgeListReq { string version = 1; string addr = 2; string txhash = 3; uint32 count = 4; } Copy 字段\t说明version\t版本号 addr\t查询地址 txhash\t该hash的下一个为起始交易,第一次使用时，使用空字符串 count\t查询数量 响应 message GetPledgeListAck { string version = 1; int32 code = 2; string description = 3; repeated PledgeItem list = 4; uint32 total = 5; string lasthash = 6; } message PledgeItem { string blockhash = 1; uint32 blockheight = 2; string utxo = 3; string amount = 4; uint64 time = 5; string fromaddr = 6; string toaddr = 7; string detail = 8; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 地址为空; -2 获得质押信息错误; -3 该地址无质押; -4 索引越界; description\t返回错误信息 list\t质押信息列表 total\t质押条目总数量 lashhash\t最后一个交易哈希 blockhash\t区块哈希 blockheight\t区块高度 utxo\tutox amount\t质押资产值 time\t时间戳 fromaddr\t发起地址 toaddr\t接收地址 detail\t详情描述 十六、获得交易信息列表请求（GetTxInfoListReq）# 请求 message GetTxInfoListReq { string version = 1; string addr = 2; string txhash = 3; uint32 count = 4; } Copy 字段\t说明version\t版本号 addr\t地址 txhash\t该hash的下一个为起始交易,第一次使用时，使用空字符串 count\t查询数量 响应 message GetTxInfoListAck { string version = 1; int32 code = 2; string description = 3; repeated TxInfoItem list = 4; uint32 total = 5; string lasthash = 6; } message TxInfoItem { TxInfoType type = 1; string txhash = 2; uint64 time = 3; string amount = 4; } enum TxInfoType { TxInfoType_Unknown = 0; TxInfoType_Originator = 1; TxInfoType_Receiver = 2; TxInfoType_Gas = 3; TxInfoType_Award = 4; TxInfoType_Pledge = 5; TxInfoType_RedeemPledge = 6; TxInfoType_PledgedAndRedeemed = 7; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 地址长度不正确; -2 获得交易信息失败; -3 该地址无交易信息; -4 索引越界; -5 获得交易信息错误; description\t返回错误信息 list\t交易信息列表 total\t交易条目总数量 lasthash\t最后一个交易哈希 type\t交易类型，详见enum TxInfoType类型说明 txhash\t交易哈希 time\t时间戳 amount\t交易额 TxInfoType_Unknown\t未知 TxInfoType_Originator\t交易发起方 TxInfoType_Receiver\t交易接收方 TxInfoType_Gas\t手续费奖励 TxInfoType_Award\t区块奖励 TxInfoType_Pledge\t质押 TxInfoType_RedeemPledge\t解除质押 TxInfoType_PledgedAndRedeemed\t质押但已解除 3.代码示例 # 获得交易信息列表请求（GetTxInfoListReq） def GetTxInfoListRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' ADDRESS = '13C4UmhB7tKGdXiJrp2GKsJtmCoJeqGJQz' TXHASH = '' COUNT = 5 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetTxInfoListReq() addr.version = VERSION addr.addr = ADDRESS addr.txhash = TXHASH addr.count = COUNT common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetTxInfoListReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetTxInfoListAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetTxInfoListReq = protobuf_to_dict(target) json_output = json.dumps(message_GetTxInfoListReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十七、获得交易详情接口（GetTxInfoDetailReq）# 请求 message GetTxInfoDetailReq { string version = 1; string txhash = 2; string addr = 3; } Copy 字段\t说明version\t版本号 txhash\t交易哈希 addr\t地址，传空值则不会查询针对该地址的奖励信息 响应 message GetTxInfoDetailAck { string version = 1; int32 code = 2; string description = 3; string blockhash = 4; uint32 blockheight = 5; string txhash = 6; uint64 time = 7; repeated string fromaddr = 8; repeated string toaddr = 9; string gas = 10; string amount = 11; string award = 12; string awardGas = 13; string awardAmount = 14; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 传入的交易哈希值为空; -2 获得区块错误; -3 获得区块信息错误 -4 区块错误; description\t返回错误信息 blockhash\t区块哈希 blockheight\t区块高度 txhash\t交易哈希 time\t时间戳 fromaddr\t发起地址 toaddr\t接收地址 gas\t付出交易Gas amount\t交易额 award\t奖励额 awardGas\t获得奖励Gas awardAmount\t区块奖励 3.代码示例 # 获得交易详情接口（GetTxInfoDetailReq） def GetTxInfoDetailRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' TXHASH = 'ae32299aebe597985c62dff443f7d73925367ddb52de9c23eefe8ef1736587e0' ADDR = '1Aw58713G6hSAJ9iiiX1JZhRrudbPSCDhK' # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDRS = (HOST, PORT) # 连接服务器 pd.connect(ADDRS) # 发送数据 addr = protobuf_pb2.GetTxInfoDetailReq() addr.version = VERSION addr.txhash = TXHASH addr.addr = ADDR common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetTxInfoDetailReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetTxInfoDetailAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetServiceInfoReq = protobuf_to_dict(target) json_output = json.dumps(message_GetServiceInfoReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十八、获得区块列表接口（GetBlockInfoListReq）# 请求 message GetBlockInfoListReq { string version = 1; uint32 index = 2; uint32 count = 3; } Copy 字段\t说明version\t版本号 index\t索引 count\t数量 响应 message GetBlockInfoListAck { string version = 1; int32 code = 2; string description = 3; uint32 top = 4; uint32 txcount = 5; repeated BlockInfoItem list = 6; } message BlockInfoItem { string blockhash = 1; uint32 blockheight = 2; uint64 time = 3; string txHash = 4; repeated string fromAddr = 5; repeated string toAddr = 6; string amount = 7; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 版本不兼容; -2 读取数据失败; -3 获得区块高度失败; -4 获得交易数量失败; -5 获得交易数量失败; -6 保留; -7 获得区块哈希值错误; -8 获得区块错误 description\t返回错误信息 top\t总高度 txcount\t总交易笔数 list\t区块信息列表 blockhash\t区块哈希 blockheight\t区块高度 time\t时间戳 txHash\t交易哈希 fromAddr\t发起方地址 toAddr\t接收方地址 amount\t交易额 3.代码示例 # 获得区块列表接口（GetBlockInfoListReq） def GetBlockInfoListRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' INDEX = 1 COUNT = 5 # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetBlockInfoListReq() addr.version = VERSION addr.index = INDEX addr.count = COUNT common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetBlockInfoListReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetBlockInfoListAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetBlockInfoListReq = protobuf_to_dict(target) json_output = json.dumps(message_GetBlockInfoListReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 十九、获得区块详情请求（GetBlockInfoDetailReq）# 请求 message GetBlockInfoDetailReq { string version = 1; string blockhash = 2; } Copy 字段\t说明version\t版本号 blockhash\t区块hash 响应 message GetBlockInfoDetailAck { string version = 1; int32 code = 2; string description = 3; string blockhash = 4; uint32 blockheight = 5; string merkleRoot = 6; string prevHash = 7; uint64 time = 8; string tatalAmount = 9; repeated string signer = 10; repeated BlockInfoOutAddr blockInfoOutAddr = 11; } message BlockInfoOutAddr { string addr = 1; string amount = 2; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 版本不兼容; -2 读取数据失败; -3 获得区块失败 description\t返回错误信息 blockhash\t区块哈希 blockheight\t区块高度 merkleRoot\tMerkle树根哈希 prevHash\t前置区块哈希 time\t时间戳 tatalAmount\t交易总额,不包括手续费 signer\t签名者 blockInfoOutAddr\t交易额 addr\t接收方地址 amount\t接收金额 3.代码示例 # 获得区块详情请求（GetBlockInfoDetailReq） def GetBlockInfoDetailRequest(): # 固定参数(参数可修改) HOST = '192.168.1.141' PORT = 11187 VERSION = '1_1.3_p' # BLOCKHASH = '035a73e3b4998a6b6655b8226056d96037c2f5e87451fa7d4bfe868f462e4a3b' BLOCKHASH = 'efbb962803348012719f6260c60c30e0a561c31fe0f85737f1aa27a049da9253' # 创建socket请求 pd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ADDR = (HOST, PORT) # 连接服务器 pd.connect(ADDR) # 发送数据 addr = protobuf_pb2.GetBlockInfoDetailReq() addr.version = VERSION addr.blockhash = BLOCKHASH common = protobuf_pb2.CommonMsg() common.version = VERSION common.type = 'GetBlockInfoDetailReq' # 序列化 common.data = addr.SerializeToString() sendData = common.SerializeToString() # 获取协议总长度 data_len = len(sendData) + 4 + 4 data_len_ = ('<i%dsIi' % (data_len - 8)) end_flag = 7777777 # 拼接消息 Splicing_String = struct.pack(data_len_, data_len, sendData, adler32(sendData), end_flag) pd.send(Splicing_String) target = protobuf_pb2.GetBlockInfoDetailAck() while True: reply = pd.recv(4) time.sleep(0.1) # 接收前四个字节，解析数据长度 test = int.from_bytes(reply, byteorder='little') # 根据数据长度再次接收数据 reply2 = pd.recv(test) # 将接收到的数据的最后8字节删除,最后8字节的内容是校验和、end_flag reply3 = reply2[:(test - 8)] # 反序列化reply3 common.ParseFromString(reply3) target.ParseFromString(common.data) # 格式化数据，并转为字典格式 message_GetBlockInfoDetailReq = protobuf_to_dict(target) json_output = json.dumps(message_GetBlockInfoDetailReq, indent=4, ensure_ascii=False) # 返回json数据 return json_output Copy 二十、获取交易失败列表请求（GetTxFailureListReq）# 请求 message GetTxFailureListReq { string version = 1; string addr = 2; string txhash = 3; uint32 count = 4; } Copy 字段\t说明version\t版本号 addr\t查询地址 txhash\t该hash的下一个为起始交易,第一次使用时，使用空字符串 count\t查询数量 响应 message GetTxFailureListAck { string version = 1; int32 code = 2; string description = 3; uint32 total = 4; repeated TxFailureItem list = 5; string lasthash = 6; } message TxFailureItem { string txHash = 1; repeated string vins = 2; repeated string fromaddr = 3; repeated string toaddr = 4; string amount = 5; uint64 time = 6; string detail = 7; string gas = 8; repeated string toAmount = 9; TxType type = 10; } Copy 字段\t说明version\t版本号 code\t返回错误码 0 成功; -1 地址为空; -2 失败列表信息为空; -3 索引越界; -4 没有找到哈希; description\t返回错误信息 total\t失败列表条目总数量 list\t失败信息列表 lashhash\t最后一个交易哈希 txHash\t交易哈希 vins\tvins fromaddr\t发起地址 toaddr\t接收地址 amount\t金额资产值 time\t时间戳 detail\t详情描述 gas\t签名费 toAmount\t每账户金额 type\t交易类型 "},{"title":"jsonrpc接口","type":1,"pageTitle":"开放接口","url":"开发者/开放接口#jsonrpc接口","content":"说明：jsonrpc标准为2.0，文档中的数据皆为测试数据，请求方式为 POST 默认端口为11190，可以在配置文件config.json中\"http_port\"属性中指定端口值 请求示例# 可使用HTTP工具Postman或者Curl进行访问测试 一、Postman示例# Postman：新建\"Request\"--> 选择\"POST\" --> 输入URL地址，需包含端口号11190（如：192.168.1.51:11190/）-->选择Body,选择Raw选项，输入json请求内容， 如:{ \"jsonrpc\": \"2.0\", \"method\": \"get_height\", \"id\": \"1\" } 填写完毕后，点击\"Send\"按钮，服务端响应请求并发回响应内容。 二、Curl示例# Curl: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{ \"jsonrpc\": \"2.0\", \"method\": \"get_height\", \"id\": \"1\" }' 192.168.1.51:11190 Copy 输入上面内容，即可访问get_height接口 接口介绍# 一、获取高度（get_height）# 请求参数 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_height\" } Copy 成功返回： { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"result\": { \"height\": \"100\" } } Copy 失败返回： { \"error\": { \"code\": -32601, \"message\": \"Method not found\" }, \"id\": \"\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求: jsonrpc\t字符串类型\t2.0标准 (相同字段以下不再重复) id\t字符串类型\t编号，客户端发送什么，服务端回复相同的编号 (相同字段以下不再重复) method\t字符串类型\t调用的方法名 (相同字段以下不再重复) 响应: result\tjson对象\t调用成功返回的结果信息 (相同字段以下不再重复) height\t字符串类型\t区块高度 error\tjson对象\t调用出错返回的结果信息 (相同字段以下不再重复) code\t整型\t错误码 (相同字段以下不再重复) message\t字符串类型\t错误描述 (相同字段以下不再重复) curl示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_height\", \"id\": \"1\" }' 192.168.1.51:11190 Copy python示例: 获取高度: def get_height(): data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_height\" } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 二、通过高度获取所有交易hash (get_txids_by_height)# 请求: { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_txids_by_height\", \"params\": { \"height\": \"1\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": [ \"772298b54a30e8b9e51b677a497369e19c3bc8ad500bf418b968638fd5d2960f\", \"6916d3a37128df383326249abfd57fec11fe693ca1b802bb0e0a9293a688c520\", \"7744719b0014bf6f733b9a0624a78273e0cf90818dd5fb02b623a0229990cebb\" ] } Copy 失败返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求的高度格式输入错误： { \"error\": { \"code\": -1, \"message\": \"height is invalid\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求的高度超过最高块的高度： { \"error\": { \"code\": -4, \"message\": \"height more than block top \" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明: 字段\t类型\t字段说明请求: params\tjson对象\t方法所需要的参数(相同字段以下不再重复) height\t字符串类型\t区块高度 响应: result\tjson对象\t当前区块高度所有交易hash组成的json数组 示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_txids_by_height\", \"params\": {\"height\": \"1\"} }' 192.168.1.51:11190 Copy python示例: 通过高度获取所有交易hash 接口：def get_txids_by_height()  height = input(\"请输入要查询的高度:\") data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_txids_by_height\", \"params\": { \"height\": height } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 三、根据地址获取余额（get_balance）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_balance\", \"params\": { \"address\": \"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"balance\": \"888.666668\" } } Copy 失败返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 查询地址格式输入错误： { \"error\": { \"code\": -1, \"message\": \"address is invalid \" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求: address\t字符串类型\t钱包地址 响应: balance\t字符串类型\t钱包余额 示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_balance\", \"params\": { \"address\":\"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\" } }' 192.168.1.51:11190 Copy python示例 根据地址获取余额（get_balance） 接口：def get_balance()  address = input(\"请输入要查询的地址:\") data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_balance\", \"params\": { \"address\": address } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 四、根据交易hash获取交易详情 (get_tx_by_txid)# 请求: { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_tx_by_txid\", \"params\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\", \"time\": 1603854991179495, \"type\": \"tx\" \"height\": \"\" \"vin\": [ { \"address\": \"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\", \"output_index\": 0, \"output_value\": \"1000.000000\", \"prev_hash\": \"4df2ac157683a5553503731aa74495c556f46faf11c595b95ee5980f8b5013b0\" } ], \"vout\": [ { \"address\": \"1FoQKZdUNeBXV2nTba6e354m5JrQ4rHYgA\", \"value\": \"10.000000\" }, { \"address\": \"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\", \"value\": \"989.000000\" } ] } } Copy 没有查找到该笔交易返回： { \"error\": { \"code\": -32000, \"message\": \"not find\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 参数错误返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 哈希长度不等于64： { \"error\": { \"code\": -1, \"message\": \"hash is invalid\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求: hash\t字符串类型\t交易hash 响应: hash\t字符串类型\t交易hash time\t无符号64位整型\t时间戳 type\t字符串类型\t交易的类型,有三种类型,只需要处理正常交易类型: \"tx\"正常交易;\"pledge\"质押交易;\"redeem\"解质押交易 height\t字符串类型\t当前交易所在区块高度 vin\tjson数组\t交易输入 address\t字符串类型\t交易转出地址 prev_hash\t字符串类型\tutxo所在的交易hash output_index\t整型\t索引 output_value\t字符串类型\tutxo金额 vout\tjson数组\t交易转入地址和金额组成的json对象 address\t字符串类型\t交易转入地址 value\t字符串类型\t交易金额 实际花费的fee计算：vin里的output_value 减去 vout 里的所有value 示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_tx_by_txid\", \"params\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\" } }' 192.168.1.51:11190 Copy python示例 根据交易hash获取交易详情 接口：def get_tx_by_txid()  hash = input(\"请输入要查询的交易hash:\") data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_tx_by_txid\", \"params\": { \"hash\": hash } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 五、创建交易体 (create_tx_message)# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"create_tx_message\", \"params\": { \"from_addr\": [\"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\"], \"to_addr\": [{\"addr\": \"1FoQKZdUNeBXV2nTba6e354m5JrQ4rHYgA\", \"value\": \"22.222222\"}], \"fee\": \"0.555555\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_data\": \"EM2nvbfKuOwCIiIxQnVGcERtSDJiSmhxeFFveXY4Y0M4WUwzbVUyVG5VREVTMig4ZjU1M2U5ODA4MzM4MjZhMDIxYWQ5MTU4MDA5N2E5OGVkY2EzM2M3QkQKQgpAMDEwZDJmYTBkNzkwNDEzNDlmM2QwZWFmY2FjMzg5ZTQ4NTM1MzgyYzE1M2VmYzNiYWZlZjFjMTcyNjU5ZjU2YUopCI6rzAoSIjFGb1FLWmRVTmVCWFYyblRiYTZlMzU0bTVKclE0ckhZZ0FKKgjY4M+cAxIiMUJ1RnBEbUgyYkpocXhRb3l2OGNDOFlMM21VMlRuVURFU1JDeyJHYXNGZWUiOjU1NTU1NSwiTmVlZFZlcmlmeVByZUhhc2hDb3VudCI6MywiVHJhbnNhY3Rpb25UeXBlIjoidHgifQ==\", \"tx_encode_hash\": \"3c9a103d8542750dd048eecf2151b052ed26051f201246089bfc01e508ed7000\" } } Copy 创建交易失败返回： { \"error\": { \"code\": -32000, \"message\": \"create fail,error number:-2\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 参数错误返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求的时候value格式输入错误：(\"value\":1.2345678 或者\"value\"：\"abc\"等) { \"error\": { \"code\": -32602, \"message\": \"The value is wrong or More than 6 decimal places\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求: from_addr\t字符串类型\t交易hash to_addr\tjson数组\t交易转入地址结构 addr\t字符串类型\t交易转入地址 value\t字符串类型\t交易金额 fee\t字符串类型\t交易燃料费 响应: tx_data\t字符串类型\t交易体(base64编码) tx_encode_hash\t字符串类型\t交易体hash(待签名信息) 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"create_tx_message\", \"params\": { \"from_addr\": [\"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\"], \"to_addr\": [{\"addr\": \"1FoQKZdUNeBXV2nTba6e354m5JrQ4rHYgA\", \"value\": \"22.222222\"}], \"fee\": \"0.555555\"} }' 192.168.1.51:11190 Copy python示例 通过调用create_tx_message rpc接口，创建交易体数据 接口：def create_tx_message()  data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"create_tx_message\", \"params\": { \"from_addr\": [\"1FJpJQkhunjirwjKm85f1P6LcCGnF4Tfet\"], \"to_addr\": [{\"addr\": \"1McVeDa3cM6A9939wKqLmnuxp863fZXXiC\", \"value\": \"4.1\"}], \"fee\": \"0.1\" } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) result = json.loads(res.text) tx_data = result[\"result\"][\"tx_data\"] tx_encode_hash = result[\"result\"][\"tx_encode_hash\"] dict_list = {'tx_data': tx_data, 'tx_encode_hash': tx_encode_hash} return_value = json.dumps(dict_list) return return_value Copy 六、发送交易 (send_tx)# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"send_tx\", \"params\": { \"tx_data\": \"ELvdqOvRuOwCIiIxQnVGcERtSDJiSmhxeFFveXY4Y0M4WUwzbVUyVG5VREVTMig4ZjU1M2U5ODA4MzM4MjZhMDIxYWQ5MTU4MDA5N2E5OGVkY2EzM2M3QkQKQgpAMjRkMjUxMzMxZGFkYjEyMGMyYmYxMDlhZDI2ODllOWNkMDcwYTAyZWJkZWQxNDA1ZTM5MGFlMmVhMDI0YjEzMEopCI6rzAoSIjFGb1FLWmRVTmVCWFYyblRiYTZlMzU0bTVKclE0ckhZZ0FKKgiwua+GAxIiMUJ1RnBEbUgyYkpocXhRb3l2OGNDOFlMM21VMlRuVURFU1JDeyJHYXNGZWUiOjU1NTU1NSwiTmVlZFZlcmlmeVByZUhhc2hDb3VudCI6MywiVHJhbnNhY3Rpb25UeXBlIjoidHgifQ==\", \"tx_signature\": \"N1ii0dikr0NJRvi7GXkjXOayD+mVcMfXF+49iOmOneYqYj2HHYzNm3Txj/otW/K7Dh3uBJ2Gb4nlTJW2AY3Dog==\", \"public_key\": \"ICBszM0aHCpWmDdEC3GMBL6DFN7XdWzijF33uvmWKMa1WbvWBk33+G9E4pSztJWlwDkvEt4dW4oGY8/sY2FJBtPG\", \"tx_encode_hash\": \"b3b8f15852efddbdfe8aa759a2f026488350b6f56a4cae7494ea3cbba0f8a5c5\" } } Copy 成功返回值: { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"tx_hash\": \"e241d6af1b8f8ff58508f14177005b4263d26e32a2e0d0f6b8e98d966cbaa864\" } } Copy 验证签名失败返回： { \"error\": { \"code\": -32000, \"message\": \"create fail,error number:-8\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 参数错误返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求: tx_data\t字符串类型\t交易体(base64编码),创建交易体方法调用后返回的tx_data tx_signature\t字符串类型\t对交易体hash(tx_encode_hash)进行签名得到的签名信息,调用动态库 public_key\t字符串类型\t公钥(base64编码) tx_encode_hash\t字符串类型\t交易体hash(待签名信息),创建交易体方法调用后返回的tx_encode_hash fee\t字符串类型\t交易燃料费 响应: tx_hash\t字符串类型\t交易hash(可通过此hash查询完整交易信息) txsignature值需要调用文档中的静态库里的GenSign()方法进行签名 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"send_tx\", \"params\": { \"tx_data\":\"ELvdqOvRuOwCIiIxQnVGcERtSDJiSmhxeFFveXY4Y0M4WUwzbVUyVG5VREVTMig4ZjU1M2U5ODA4MzM4MjZhMDIxYWQ5MTU4MDA5N2E5OGVkY2EzM2M3QkQKQgpAMjRkMjUxMzMxZGFkYjEyMGMyYmYxMDlhZDI2ODllOWNkMDcwYTAyZWJkZWQxNDA1ZTM5MGFlMmVhMDI0YjEzMEopCI6rzAoSIjFGb1FLWmRVTmVCWFYyblRiYTZlMzU0bTVKclE0ckhZZ0FKKgiwua+GAxIiMUJ1RnBEbUgyYkpocXhRb3l2OGNDOFlMM21VMlRuVURFU1JDeyJHYXNGZWUiOjU1NTU1NSwiTmVlZFZlcmlmeVByZUhhc2hDb3VudCI6MywiVHJhbnNhY3Rpb25UeXBlIjoidHgifQ==\", \"tx_signature\": \"N1ii0dikr0NJRvi7GXkjXOayD+mVcMfXF+49iOmOneYqYj2HHYzNm3Txj/otW/K7Dh3uBJ2Gb4nlTJW2AY3Dog==\", \"public_key\": \"ICBszM0aHCpWmDdEC3GMBL6DFN7XdWzijF33uvmWKMa1WbvWBk33+G9E4pSztJWlwDkvEt4dW4oGY8/sY2FJBtPG\", \"tx_encode_hash\": \"b3b8f15852efddbdfe8aa759a2f026488350b6f56a4cae7494ea3cbba0f8a5c5\"} }' 192.168.1.51:11190 Copy python示例 调用send_tx rpc接口发送交易 @param tx_data 创建交易体(create_tx_message)返回的tx_data @param tx_signature 生成签名信息（generate_sign）返回的message信息 @param public_key 生成钱包地址、公钥和私钥（generate_wallet）返回的public_key @param tx_encode_hash 创建交易体(create_tx_message)返回的tx_encode_hash 接口： def send_tx(tx_data, tx_signature, public_key, tx_encode_hash)  data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"send_tx\", \"params\": { \"tx_data\": tx_data, \"tx_signature\": tx_signature, \"public_key\": public_key, \"tx_encode_hash\": tx_encode_hash } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) result = json.loads(res.text) Copy 七、获取最近100块高度的平均交易燃料费 （get_avg_fee）# 说明： fee由矿工自主设置，如果发送交易时设置的fee值低于大多数矿工设置的fee值，可能会造成交易不成功，因此，可以参照最近100个高度的区块平均fee值来设定，确保交易能成功。 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_avg_fee\" } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"avg_fee\": \"0.112074\" } } Copy 失败返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 响应： avg_fee 字符串类型 最近100个高度区块fee的平均值,如果高度不足100,则是所有区块的平均值 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_avg_fee\", \"id\": \"1\" }' 192.168.1.51:11190 Copy python示例 获取最近100块高度的平均交易燃料费 def get_avg_fee(): data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_avg_fee\" } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 八、生成钱包地址、公钥和私钥（generate_wallet）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"generate_wallet\" } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"address\": \"1BGmh7NgY7spKRBHJkwQTZosaHGiXfynvj\", \"private_key\": \"xAEF+gTQZ6PmtH3hlmygJpAVxBpKHBa3Zw8iMxRjlbQ=\", \"public_key\": \"ICD6bienPIel1KE4WmGlQ6bC6M+HiPTw3+et036AUaTVtLr1iV1DMFFx2O9VYi/MUXOZyKK87s/GjPE+eN9A+wEl\" } } Copy 失败返回： { \"error\": { \"code\": -32601, \"message\": \"Method not found\" }, \"id\": \"\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明响应: address\t字符串类型\t钱包地址 private_key\t字符串类型\tbase64编码后的私钥 public_key\t字符串类型\tbase64编码后的公钥 示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"generate_wallet\", \"id\": \"1\" }' 192.168.1.51:11190 Copy python示例: 通过调用generate_wallet rpc接口，生成钱包地址和相应的公私钥 def generate_wallet(): data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"generate_wallet\" } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) result = json.loads(res.text) address = result[\"result\"][\"address\"] private_key = result[\"result\"][\"private_key\"] public_key = result[\"result\"][\"public_key\"] dict_list = {'address': address, 'private_key': private_key, 'public_key': public_key} return_value = json.dumps(dict_list) return return_value Copy 九、生成签名信息（generate_sign）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"generate_sign\", \"params\": { \"data\": \"b3b8f15852efddbdfe8aa759a2f026488350b6f56a4cae7494ea3cbba0f8a5c5\", \"private_key\": \"xAEF+gTQZ6PmtH3hlmygJpAVxBpKHBa3Zw8iMxRjlbQ=\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"message\": \"Ggy2ouJDIZw9/ShvZUwXyVgsAXSFLsxvRCh42elAf+Klit6DJH/jUY6Z3Km/W7VhPKinrsHcaEcwYqIUIwopWQ==\" } } Copy 失败返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： data\t字符串类型\t待签名信息, create_tx_message方法调用后返回的tx_encode_hash private_key\t字符串类型\tbase64编码后的私钥 响应： message\t字符串类型\tbase64编码后的已签名信息 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"generate_sign\", \"id\": \"1\", \"params\": { \"data\": \"b3b8f15852efddbdfe8aa759a2f026488350b6f56a4cae7494ea3cbba0f8a5c5\", \"private_key\": \"xAEF+gTQZ6PmtH3hlmygJpAVxBpKHBa3Zw8iMxRjlbQ=\" } }' 192.168.1.51:11190 Copy python示例 调用generate_sign rpc接口进行签名 @param tx_encode_hash 创建交易体(create_tx_message)返回的tx_encode_hash @param private_key 生成钱包地址、公钥和私钥(generate_wallet)返回的private_key def generate_sign(tx_encode_hash, private_key): data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"generate_sign\", \"params\": { \"data\": tx_encode_hash, \"private_key\": private_key } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) result = json.loads(res.text) //获取签名之后返回的message* message = result[\"result\"][\"message\"] //将message封装成json格式 dict_list = {\"message\": message} return_value = json.dumps(dict_list) return return_value Copy 十、查询正在挂起的交易（get_pending_transaction）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_pending_transaction\", \"params\": { \"address\": \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"total\": 1, \"transaction\": [ { \"amount\": \"501\", \"broadstamp\": 1620378873518030, \"from\": [ \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" ], \"gap\": \"0.050000\", \"hash\": \"4303e57195616797f77d7db888ef15d677740d8f10a9a8e29370d35c3cc853fb\", \"timestamp\": 1620378873279899, \"to\": [ \"1HjrxHbBuuyNQDwKMh4JtqfuGiDCLodEwC\" ], \"toAmount\": [ \"501.000000\" ], \"vin\": [ \"7d9a0cb698db789b5f294343209b94ca69119f02593cb5607069623810f6ed69\", \"92c45d62b86d37c04f5f873eedfdcb1719eeca9a43e16b206e98101d20baeb0c\", \"d2c9da85e7b67188c507f40a95cba88c491afca56b863cce6af512638c7b1b1c\" ] } ] } } Copy 失败返回如请求的地址格式输入错误： { \"error\": { \"code\": -1, \"message\": \"address is invalid\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： address\t字符串类型\t交易发起方地址 响应： total\t数值类型\t处于挂起的交易的个数 transaction\t数组类型\t交易内容,包括交易的哈希，发起方，接收方，金额，时间戳 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_pending_transaction\", \"id\": \"1\", \"params\": { \"address\": \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\"} }' 192.168.1.51:11190 Copy python示例 查询正在挂起的交易 接口：def get_pending_transaction()  address = input(\"请输入要查询的地址:\") data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_pending_transaction\", \"params\": { \"address\": address } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(res.text) Copy 十一、查询失败的交易（get_failure_transaction）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_failure_transaction\", \"params\": { \"address\": \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"total\": 1, \"transaction\": [ { \"amount\": \"500\", \"from\": [ \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" ], \"gap\": \"0.050000\", \"hash\": \"13f9730d0ce5fe401352f42fdce3677e324d15518857c02e0aafc6b5456a7676\", \"timestamp\": 1609313648455902, \"to\": [ \"1HjrxHbBuuyNQDwKMh4JtqfuGiDCLodEwC\" ], \"toAmount\": [ \"500.000000\" ], \"vin\": [ \"b8930d79b8ecbdd2141d3b4fa85fa7dc0e4c6b3c3e30a379d573aacd34299b18\", \"c99ac37f9a9c591e51ea31551455f3662eac4e54a1c27923a81e7966c0eadbfa\", \"08cb13dea1510860de5549a71c8142e16af6698b9b0d9bea3a813789727d084f\" ] } ] } } Copy 返回失败 请求的地址格式输入错误： { \"error\": { \"code\": -1, \"message\": \"address isinvalid\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： address\t字符串类型\t交易发起方地址 响应： total\t数值类型\t处于挂起的交易的个数 transaction\t数组类型\t交易内容,包括交易的哈希，发起方，接收方，金额，时间戳 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_failure_transaction\", \"id\": \"1\", \"params\": { \"address\": \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\"} }' 192.168.1.51:11190 Copy python示例 查询失败的交易 def get_failure_transaction(): address = input(\"请输入要查询的地址:\") data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_failure_transaction\", \"params\": { \"address\": address } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) result = json.loads(res.text) Copy 十二、获取块信息列表（get_block_info_list）# 请求 { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_block_info_list\", \"params\": { \"index\": \"15\", \"count\": \"3\", \"type\": \"0\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"height\": [ [ { \"block_hash\": \"b4f74ea3a735a0e6de5c4041bbecfc1b6e2a30156ad41ade7e98c9992e3141ec\", \"block_height\": 15, \"block_time\": 1611132153984580, \"tx\": { \"amount\": \"3099.000000\", \"from\": [ \"1vkS46QffeM4sDMBBjuJBiVkMQKY7Z8Tu\" ], \"hash\": \"b9b417999b0e4d165d822e9fa9c8fdc553fdd9d6affb054d0a258f6d3db352ee\", \"to\": [ \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" ] } } ], [ { \"block_hash\": \"9870c60872e171b747f35e2f4e876e0792833cb8a258151e38aa1c7f72a52734\", \"block_height\": 14, \"block_time\": 1611131849651811, \"tx\": { \"amount\": \"3983.000000\", \"from\": [ \"1vkS46QffeM4sDMBBjuJBiVkMQKY7Z8Tu\" ], \"hash\": \"98a483aa1c0b77fed0b69c36888fe6e953fe96d5432a17704e76e4f5a5bc2d64\", \"to\": [ \"1TT8sdzyPhqSmSx7Wdmn1ECeEHZKosh6v\" ] } } ], [ { \"block_hash\": \"e79fb3d28be54e12a7e5ae9c21d91cefc6ba0d8f25681717d07348b569083f3f\", \"block_height\": 13, \"block_time\": 1611050624949290, \"tx\": { \"amount\": \"2349.000000\", \"from\": [ \"1vkS46QffeM4sDMBBjuJBiVkMQKY7Z8Tu\" ], \"hash\": \"bfe2bf795003c2960d09ad03b1d9dd5bc2109c3eba3fe790fd2001f43ce1fc8b\", \"to\": [ \"1MpeeKXwH1ArnMJ85D161yfH1us471J86X\" ] } } ] ] } } Copy 失败返回 请求端输入的index格式出错： { \"error\": { \"code\": -32602, \"message\": \"index Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求端输入的count格式出错： { \"error\": { \"code\": -32602, \"message\": \"count Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求端输入的count不能为0： { \"error\": { \"code\": -1, \"message\": \"count is not equal zero！\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 请求端输入的type格式出错：  { \"error\": { \"code\": -32602, \"message\": \"type Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： index\t数值类型\t块最高起始索引地址。可以指定0，从当前最高块读取 count\t数值类型\t要读取的块的个数，从高向低列出 type\t数值类型\t默认为0，以后扩展使用 响应： height\t数组类型\t每一高度层的块数据 block_hash\t字符串类型\t块的哈希 block_height\t数值类型\t块所在的高度 block_time\t数值类型\t建块的时间 amount\t字符串类型\t交易金额 from\t数组类型\t交易发起者 hash\t字符串类型\t交易哈希 to\t数组类型\t交易接收者 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"get_block_info_list\", \"id\": \"1\", \"params\": { \"index\": \"15\", \"count\": \"3\", \"type\":\"0\" } }' 192.168.1.51:11190 Copy python示例 获取块信息列表 接口：def get_block_info_list()  data = { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_block_info_list\", \"params\": { \"index\": \"15\", \"count\": \"3\", \"type\": \"0\" } } headers = { \"Content-Type\": \"application/json\" } res = requests.post( url=domain, data=json.dumps(data), headers=headers) print(\"get_block_info_list res.text:\", res.text) result = json.loads(res.text) Copy 十三、确认交易是否成功（confirm_transaction）# 请求： { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"confirm_transaction\", \"params\": { \"tx_hash\": \"d7ef410796ffa9ef60982c3470f5d816c28a4ea2d3c5299228ef2f5997bf8221\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"nodeid\": [ \"d0b206ec2cee4c04b614d7dc4f9b83584269acd8\", \"c0f710f6b70588bd92983bf50ac710d94f913141\", \"8e41e25eb4ee88a52c34f159d33ada701ce68469\", \"5addc8e04079cc00c49754833b81f67b9458cff5\", \"797a07e6ff413bb35c75243efa087fdc714e0a7d\", \"bc37516cdea7acf3938049219698b9d7db493eba\", \"003f2d85999a6ad668e66dc7cf1ec20dfc1aa9c0\" ], \"success\": 1, \"total\": 7 } } Copy 失败返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"nodeid\": null, \"success\": 0, \"total\": 0 } } Copy tx_hash参数格式错误： { \"error\": { \"code\": -32700, \"message\": \"Parse error\" }, \"id\": \"\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： tx_hash\t字符串类型\t本次交易的交易哈希 响应： nodeid\t数组类型\t返回成功建块的节点ID total\t数值类型\t成功本次交易节点确认之后返回的个数 success\t布尔类型\t成功与否 示例 curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"method\": \"confirm_transaction\", \"id\": \"1\", \"params\": { \"tx_hash\": \"d7ef410796ffa9ef60982c3470f5d816c28a4ea2d3c5299228ef2f5997bf8221\"} }' 192.168.1.51:11190 Copy 十四、根据交易哈希和节点ID获取交易详情（get_tx_by_txid_and_nodeid）# 请求: { \"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_tx_by_txid\", \"params\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\", \"nodeid\":\"d0b206ec2cee4c04b614d7dc4f9b83584269acd8\" } } Copy 成功返回： { \"id\": \"1\", \"jsonrpc\": \"2.0\", \"result\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\", \"time\": 1603854991179495, \"type\": \"tx\" \"height\": \"\" \"vin\": [ { \"address\": \"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\", \"output_index\": 0, \"output_value\": \"1000.000000\", \"prev_hash\": \"4df2ac157683a5553503731aa74495c556f46faf11c595b95ee5980f8b5013b0\" } ], \"vout\": [ { \"address\": \"1FoQKZdUNeBXV2nTba6e354m5JrQ4rHYgA\", \"value\": \"10.000000\" }, { \"address\": \"1BuFpDmH2bJhqxQoyv8cC8YL3mU2TnUDES\", \"value\": \"989.000000\" } ] } } Copy 没有查找到该笔交易返回： { \"error\": { \"code\": -32000, \"message\": \"not find\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 参数错误返回： { \"error\": { \"code\": -32602, \"message\": \"Invalid params\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 哈希长度不等于64： { \"error\": { \"code\": -1, \"message\": \"hash is invalid\" }, \"id\": \"1\", \"jsonrpc\": \"2.0\" } Copy 字段说明 字段\t类型\t字段说明请求： hash\t字符串类型\t交易hash 响应： hash\t字符串类型\t交易hash time\t无符号64位整型\t时间戳 type\t字符串类型\t交易的类型,有三种类型,只需要处理正常交易类型：\"tx\"正常交易；\"pledge\" 质押交易；\"redeem\" 解质押交易 height\t字符串类型\t当前交易所在区块高度 vin\tjson数组\t交易输入 address\t字符串类型\t交易转出地址 prev_hash\t字符串类型\tutxo所在的交易hash output_index\t整型\t索引 output_value\t字符串类型\tutxo金额 vout\tjson数组\t交易转入地址和金额组成的json对象 address\t字符串类型\t交易转入地址 value\t字符串类型\t交易金额 实际花费的fee计算：vin里的output_value 减去 vout 里的所有value 示例: curl -i -X POST -H \"Content-Type: application/json; indent=4\" -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"get_tx_by_txid_and_nodeid\", \"params\": { \"hash\": \"3bb0c305a59c45a35eb48fef3ac5a9f42104a083288b867572fa07b9a7961baa\",\"nodeid\":\"d0b206ec2cee4c04b614d7dc4f9b83584269acd8\" } }' 192.168.1.51:11190 Copy "}]